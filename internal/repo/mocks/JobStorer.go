// Code generated by mockery v2.53.0. DO NOT EDIT.

package mocks

import (
	context "context"

	repo "github.com/harsh-jagtap-josh/RozgarLink/internal/repo"
	mock "github.com/stretchr/testify/mock"
)

// JobStorer is an autogenerated mock type for the JobStorer type
type JobStorer struct {
	mock.Mock
}

// CreateJob provides a mock function with given fields: ctx, jobData
func (_m *JobStorer) CreateJob(ctx context.Context, jobData repo.Job) (repo.Job, error) {
	ret := _m.Called(ctx, jobData)

	if len(ret) == 0 {
		panic("no return value specified for CreateJob")
	}

	var r0 repo.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repo.Job) (repo.Job, error)); ok {
		return rf(ctx, jobData)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repo.Job) repo.Job); ok {
		r0 = rf(ctx, jobData)
	} else {
		r0 = ret.Get(0).(repo.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, repo.Job) error); ok {
		r1 = rf(ctx, jobData)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteJobById provides a mock function with given fields: ctx, jobId
func (_m *JobStorer) DeleteJobById(ctx context.Context, jobId int) (int, error) {
	ret := _m.Called(ctx, jobId)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJobById")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (int, error)); ok {
		return rf(ctx, jobId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) int); ok {
		r0 = rf(ctx, jobId)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, jobId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchAllJobs provides a mock function with given fields: ctx, filters
func (_m *JobStorer) FetchAllJobs(ctx context.Context, filters repo.JobFilters) ([]repo.Job, error) {
	ret := _m.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for FetchAllJobs")
	}

	var r0 []repo.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repo.JobFilters) ([]repo.Job, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repo.JobFilters) []repo.Job); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repo.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repo.JobFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchApplicationsByJobId provides a mock function with given fields: ctx, jobId
func (_m *JobStorer) FetchApplicationsByJobId(ctx context.Context, jobId int) ([]repo.ApplicationCompleteEmp, error) {
	ret := _m.Called(ctx, jobId)

	if len(ret) == 0 {
		panic("no return value specified for FetchApplicationsByJobId")
	}

	var r0 []repo.ApplicationCompleteEmp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]repo.ApplicationCompleteEmp, error)); ok {
		return rf(ctx, jobId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []repo.ApplicationCompleteEmp); ok {
		r0 = rf(ctx, jobId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repo.ApplicationCompleteEmp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, jobId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchJobById provides a mock function with given fields: ctx, jobId
func (_m *JobStorer) FetchJobById(ctx context.Context, jobId int) (repo.Job, error) {
	ret := _m.Called(ctx, jobId)

	if len(ret) == 0 {
		panic("no return value specified for FetchJobById")
	}

	var r0 repo.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (repo.Job, error)); ok {
		return rf(ctx, jobId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) repo.Job); ok {
		r0 = rf(ctx, jobId)
	} else {
		r0 = ret.Get(0).(repo.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, jobId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindJobById provides a mock function with given fields: ctx, jobId
func (_m *JobStorer) FindJobById(ctx context.Context, jobId int) bool {
	ret := _m.Called(ctx, jobId)

	if len(ret) == 0 {
		panic("no return value specified for FindJobById")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, int) bool); ok {
		r0 = rf(ctx, jobId)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// UpdateJobById provides a mock function with given fields: ctx, jobData
func (_m *JobStorer) UpdateJobById(ctx context.Context, jobData repo.Job) (repo.Job, error) {
	ret := _m.Called(ctx, jobData)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobById")
	}

	var r0 repo.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repo.Job) (repo.Job, error)); ok {
		return rf(ctx, jobData)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repo.Job) repo.Job); ok {
		r0 = rf(ctx, jobData)
	} else {
		r0 = ret.Get(0).(repo.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, repo.Job) error); ok {
		r1 = rf(ctx, jobData)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewJobStorer creates a new instance of JobStorer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewJobStorer(t interface {
	mock.TestingT
	Cleanup(func())
}) *JobStorer {
	mock := &JobStorer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
